### 最长上升子序列
上升子序列指的是对于任意的i < j都满足ai < aj的子序列，该问题被称为最长上升子序列

举个栗子：给你一个序列为（1，5 ，2，6，9，10，3，15），那么它的最长上升子序列为：（1，2，6，9，10，15）

### DP 动态规划
动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

动态规划解决方案从底部开始解决问题， 将所有小问题解决掉， 然后合并成一个整体解决方案， 从而解决掉整个大问题 。

## 时间和空间复杂度
- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。
> ([参考](https://zhuanlan.zhihu.com/p/50479555))
### 时间复制度
以下按顺序复杂度越来越大，执行的效率也就越来越低

1) 常数阶 O(1)
无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：
```js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```
2) 对数阶 
```js
int i = 1;
while(i<n)
{
    i = i * 2;
}
```
3) 线性阶 O(n)
```js
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```
4) 线性对数阶 O(nlogN)
5) 平方阶 O(n²)
6) 立方阶O(n³)
7) K次方阶O(n^k)
8) 指数阶(2^n)

### 控件复杂度

1) 空间复杂度 O(1)
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
```js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```
2) 空间复杂度 O(n)

```js
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```


## 数组和链表
数组在内存上连续的，通过下标查询是高效的，插入删除是低效，但在尾部删除添加也是高效的；

链表在内存上不连续的，靠指针指向下一个内存，对于插入、删除是高效的；

## 堆栈
