(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{377:function(t,a,s){"use strict";s.r(a);var e=s(40),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"最长上升子序列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最长上升子序列"}},[t._v("#")]),t._v(" 最长上升子序列")]),t._v(" "),s("p",[t._v("上升子序列指的是对于任意的i < j都满足ai < aj的子序列，该问题被称为最长上升子序列")]),t._v(" "),s("p",[t._v("举个栗子：给你一个序列为（1，5 ，2，6，9，10，3，15），那么它的最长上升子序列为：（1，2，6，9，10，15）")]),t._v(" "),s("h3",{attrs:{id:"dp-动态规划"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dp-动态规划"}},[t._v("#")]),t._v(" DP 动态规划")]),t._v(" "),s("p",[t._v("动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。")]),t._v(" "),s("p",[t._v("由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。")]),t._v(" "),s("p",[t._v("动态规划解决方案从底部开始解决问题， 将所有小问题解决掉， 然后合并成一个整体解决方案， 从而解决掉整个大问题 。")])])}),[],!1,null,null,null);a.default=r.exports}}]);